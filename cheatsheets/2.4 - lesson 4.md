# Rapid Prototyping with Ruby on Rails: lesson 4 (ajax, roles, and miscellaneous)

tealeaf academy

cheatsheet

## Lecture 6

- Ajax is especially important when you have an 'expensive' page with a lot of information to fetch per request
- basic ajax-structure:
- `
$(document).ready(function () {
  $('#hit_form input').click(function () { // 1. unobstrusive js event listener
    $.ajax({ // 2. trigger ajax request
      type: 'POST',
      url: '/player/hit',
      data: {param1: 'hi', param2: 'there'}
    }).done(function (msg) { // 3. handle response
      $('#some_element').html(msg);
    });
  });
});
`
- Rails helps with abstracting from this schema so ajax can be less messy
- to ajaxify a link, use `remote: true` in the link_to-helper; this will add a `data-remote?'true'` to the link-html and a piece of javascript will convert the link to an ajax-call by building the above call
- on the server side, the request will be handled `as JS`
- to respond to different formats, use `respond_to do |format| format.html { ... } format.js { ... } end`
- inside the js-response, you could return a serialized object like `render json: @post`
- the default (no block given) will be that Rails tries to render a javascript template (action_name
.js.erb)
- in the js-template we have access to the instance variables, e.g. `alert('... <%= @post.title %> ...');`, which is more powerful than pure javascript
- of course, the elements to be changed by the javascript have to be identifiable, so use something like `id="post_<%= @post.id %>"
- slugs are unique identifiers that are not just the ids
- slugs make for nicer urls that will get SEO credits when important key-words are there
- urls are generated using the named routes helpers, e.g. `post_path(post)`, and post_path will call `to_param` on its argument: `post_path(post.to_param)`, so if we overwrite this method: define a `to_param` instance method on the object (e.g. the post) that does not return the id but the slug: `def to_param; self.slug; end`
- slugs can be stored in their own database-column for the model
- we may want a corresponding `generate_slug-method` on the model (create a nice regexp for example) that returns a unique slug, e.g. `def generate_slug; self.slug = title.gsub(' ', '-').downcase; end`
- you can hook the slug generation into an ActiveRecord Callback, e.g. (after_create :generate_slug)
- the livecycle-hooks provided by ActiveRecord are `save, valid, before_validation, validate, after_validation, before_save, before_create, create, after_create, after_save, after_commit`
- if you care about bookmarking, do not change slugs

