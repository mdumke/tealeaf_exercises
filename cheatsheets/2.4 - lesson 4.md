# Rapid Prototyping with Ruby on Rails: lesson 4 (ajax, roles, and miscellaneous)

tealeaf academy

cheatsheet

## Lecture 6

- Ajax is especially important when you have an 'expensive' page with a lot of information to fetch per request
- basic ajax-structure:
- `
$(document).ready(function () {
  $('#hit_form input').click(function () { // 1. unobstrusive js event listener
    $.ajax({ // 2. trigger ajax request
      type: 'POST',
      url: '/player/hit',
      data: {param1: 'hi', param2: 'there'}
    }).done(function (msg) { // 3. handle response
      $('#some_element').html(msg);
    });
  });
});
`
- Rails helps with abstracting from this schema so ajax can be less messy
- to ajaxify a link, use `remote: true` in the link_to-helper; this will add a `data-remote?'true'` to the link-html and a piece of javascript will convert the link to an ajax-call by building the above call
- on the server side, the request will be handled `as JS`
- to respond to different formats, use `respond_to do |format| format.html { ... } format.js { ... } end`
- inside the js-response, you could return a serialized object like `render json: @post`
- the default (no block given) will be that Rails tries to render a javascript template (action_name
.js.erb)
- in the js-template we have access to the instance variables, e.g. `alert('... <%= @post.title %> ...');`, which is more powerful than pure javascript
- of course, the elements to be changed by the javascript have to be identifiable, so use something like `id="post_<%= @post.id %>"
- slugs are unique identifiers that are not just the ids
- slugs make for nicer urls that will get SEO credits when important key-words are there
- urls are generated using the named routes helpers, e.g. `post_path(post)`, and post_path will call `to_param` on its argument: `post_path(post.to_param)`, so if we overwrite this method: define a `to_param` instance method on the object (e.g. the post) that does not return the id but the slug: `def to_param; self.slug; end`
- slugs can be stored in their own database-column for the model
- we may want a corresponding `generate_slug-method` on the model (create a nice regexp for example) that returns a unique slug, e.g. `def generate_slug; self.slug = title.gsub(' ', '-').downcase; end`
- you can hook the slug generation into an ActiveRecord Callback, e.g. (after_validation :generate_slug)
- the livecycle-hooks provided by ActiveRecord are `save, valid, before_validation, validate, after_validation, before_save, before_create, create, after_create, after_save, after_commit`
- if you care about bookmarking, do not change slugs
- remember that once you start using slugs, make sure that every object actually has a slug (can be done, e.g. by calling save on all objects - which you might not want to do in production...)
- of course, when you use slugs, you have to retrieve objects by slug instead of id
- there are a lot of gems to help with slugging. 'Friendly Id' is very powerful but not so simple to use
- roles are typically introduced by setting up a `has-has-many-roles` and `role-has-many-permissions`-association structure
- then when a user wants to perform an action, you have to search through all the permissions and see if they're allowed to do what they want (which is now slowing down everything - try to convince clients to back away from introducing finegrained control that clients love...)
- a much simpler way is this: add a role-column to your user-model that takes a string, and provide a simple check on the model like `def admin?; self.role == 'admin'; end`
- now in the controller, to guard a certain action, we can simply say `before_action :require_admin`
- note that when we have a `require_admin` method we can refactor the application controller to have a general `access denied`-method that checks and redirects



