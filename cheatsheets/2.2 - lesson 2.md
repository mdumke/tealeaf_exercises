# Rapid Prototyping with Ruby on Rails: lesson 2 (Rails forms)

tealeaf academy

cheatsheet

## Lecture 3

- you cannot simply post to a controller action because for post-requests the CSRF-token is checked, at least when `protect_from_forgery` is set on this controller (or in the application controller)
- when building a controller action, its a good idea to start with `binding.pry` just to check what gets send via the params-hash
- params is a 'HashWithIndifferentAccess' which means you can access it with strings or symbols
- a form helper in Rails would be `form_tag` which takes a path (method is post by default) and within it you can use `label_tag(:some_input)` and e.g. `text_field_tag(:some_input)
- ? Is the Authenticity Token valid for a given session? Where is it generated and when does it change?
- the label helper associates labels with inputs and is used like so: `label_for :data_field, 'Text to display'`
- for model-backed forms use `form_for @object do |f|`. This will provide new methods on f, the form-builder-object, like `f.label`, `f.text_field`, `f.submit`, etc.
- when using model-backed forms, you can only refer to attributes or virtual attributes of the model, and the form-names will have the form `name=model_name[attribute_name]`
- model-backed forms prepare the names of forms in a way that makes it easy to use them in mass-assignment. For instance, the name might be `post[title]` so it would be possible to do `Post.create(params[:post])` in the controller and have the title passed in properly
- Rails 3 uses whitelisting for mass-assignment with `attr_accessible :first_name, :last_name, ...` with the model declaration
- in Rails 4 whitelisting takes place at the action-level not at the model-layer, which makes sense because permissions depend on the current context, e.g. the current user, and the model layer is much too general to provide adequate sequrity
- wrap params in a private method and whitelist them via `params.require(:model_name).permit(:attr1, :attr2, :virtual_attr1, ...)` or use `permit!` to allow everything. You migth do something like `if user.is_admin? params.require(:model_name).permit! else ...`
- a standard pattern when creating (or updating) resources: `if @item.save flash[:notice] = "all good"; redirect_to 'somewhere' else render 'new' end`
- similarly for update use `if @item.update(item_params) ...`
- validations are always added to the model layer like so `validated :title, presence: true`, but they can get quite complicated
- failing validations will populate `model_name.errors`. Messages can be accessed easily via `model_name.error.full_messages`
- why does Rails store error messages on the object? Because this way we can just render the form again (this is also why we use render instead of redirect)
- to handle errors, you might want to check with `@model_name.errors.any?` and then iterate through the errors
- rails will wrap input elements which have an id for which an error exists with a `field-with-error`-div
- `form_for` will pre-populate input fields when it is passed an existing object
- behing the scenes, http PATCH is simulated by Rails by using a POST to a resource_path/:id and passing a hidden field with name '_method' and value 'patch'. The form tag will generate this automatically when you pass in an existing post
- we can use a before_filter (Rails 3) or before_action (Rails 4) to e.g. setup instance variables before certain actions, e.g. `before_action :set_post, only: [:show, :edit, :update]`
- there are two typical use cases for before-actions: setting up instance variables and redirecting on some conditions, e.g. to check for login
- generating forms for nested resources is a bit more involved. `form_for` will now take an array of arguments like `form_for [@parent, @child]` where the parent must be an existing object
- notice the difference: you redirect to a *path*, but you render a *template*
- ? How can I change the button text in the forms so that it differs for new and update and can be translated?




