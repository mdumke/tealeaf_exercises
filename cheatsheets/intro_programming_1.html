<h1>Introduction to Programming with Ruby</h1>

<p>cheatsheet</p>

<p>tealeaf academy</p>

<h2>Preparations</h2>

<ul>
<li>use pry for debugging with: <code>require 'pry'</code> and <code>binding.pry</code></li>
<li>pry will open a repl, where you can check and manipulate variables in the current environment</li>
</ul>

<h2>The Basics</h2>

<ul>
<li>symbols, <code>:some_sym</code>, are used when something is neither intended to be <em>printed</em> to the screen nor <em>changed</em></li>
<li>print to STDOUT with <code>$stdout.puts stuff</code> (or just <code>puts stuff</code>) and to STDERR with <code>$stderr.puts error</code></li>
<li>type-conversion <code>'123.4'.to_i</code> will convert all trailing ciphers to an integer</li>
<li>the new hash-syntax as of Ruby 1.9.3 (?) is <code>key: value</code>, not <code>:key =&gt; value</code></li>
</ul>

<h2>Variables</h2>

<ul>
<li>be aware of the different variable types</li>
<li>CONSTANT</li>
<li>$global_var</li>
<li>@@class_var</li>
<li>@instance_var</li>
<li>local_var</li>
</ul>

<h2>Control Flow</h2>

<ul>
<li>the case-statement can be used without an argument! Just <code>case</code> and then provide a number of conditionals in the <code>when</code>-clauses and the first matching option will be taken</li>
<li>there are only two falsy values in Ruby: nil and false</li>
</ul>

<h2>Loops and Iterators</h2>

<ul>
<li>The simplest loop construct is <code>loop do...</code></li>
<li>all looping constructs have return values, usually either the collection they loop over or nil</li>
<li><code>break</code> and <code>next</code> work as expected</li>
<li>the while-loop has a counterpart, the until-loop</li>
<li>to create a do-while-loop, add a breaking-condition to a simle loop. It is not recommended to use the <code>begin...end while</code>-construct</li>
</ul>

<h2>Arrays</h2>

<ul>
<li>some useful array-methods would be <code>indlude?</code>, <code>sort</code>, <code>each_index</code>, <code>each_with_index</code>, <code>flatten</code></li>
<li>it might be a good idea to double-check whether or not an array-method is destructive</li>
<li>to transform a range into an array, use e.g. <code>Array(1..3)</code></li>
</ul>

<h2>Hashes</h2>

<ul>
<li>hashes have helpful iterator-methods, e.g. each<em>key, each</em>value, keys, values, each</li>
<li>merge hashes with merge or merge!</li>
</ul>

<h2>Files</h2>

<ul>
<li>create a new file using the File-object: `file = File.new('test.txt', 'w+')</li>
<li>or open the file with <code>file = File.open(...)</code></li>
<li>make it a habit close files: <code>file.close</code></li>
<li>some common modes are: <code>r</code> (read only), <code>w</code> (write only), <code>w+</code> (read and over-write), <code>a+</code> (read and append)</li>
<li>read-mode is default, so we do not have to specify this</li>
<li>to read from a file, simply use <code>File.read('filename')</code> to get the complete content as a string or <code>File.readlines('filename')</code> to have each line as an array-element</li>
<li>to write to a file, use <code>file.write</code> or <code>file.puts</code> which puts a newline-character at the end</li>
<li>a file is a stream, just like <code>$stdout</code> or <code>$stderr</code>, so we can simply write or put(s) to it</li>
<li>No need to call <code>file.close</code> when working with blocks like <code>File.open('filename', 'w') {|f| f.write('&lt;=&gt;')}</code></li>
<li>Delete files with `File.delete('filename')</li>
<li>opening a file in mode 'w' or 'w+' will truncate an existing file to zero</li>
<li>use the Dir-class to inspect and manipulate directories, e.g.</li>
<li><code>Dir.entries('.')</code> lists the contents of the current directory</li>
<li><code>Dir.foreach('.') do |f| ...</code> is an iterator over all entries in the directory</li>
<li><code>Dir.getwd</code> returns the absolute path to the current working directory</li>
<li><code>Dir.chdir('path')</code> changes the directory</li>
<li><code>Dir.mkdir('name')</code> and <code>Dir.rmdir('name')</code> can be used to create and delete directories</li>
<li>the Pathname-class can help with manipulating file paths, use as in <code>pn = Pathname.new(fileobj_or_path_as_str)</code></li>
<li>Some file classes and helpful ruby classes would be:</li>
<li>csv: use CSV-class</li>
<li>xls: use axslx-library</li>
<li>json: Ruby standard library</li>
<li>xml: Nokigiri-library</li>
</ul>

<h2>More Stuff</h2>

<ul>
<li>a simple regexp-match can be checked with <code>"str" =~ /epx/</code></li>
<li>a MatchData object is returned when using the match-method, this object has all relevant data stored, e.g.</li>
<li><code>/(\w{2})-(\w{3})/.match("abc-def").captures</code> will show a list of the captured groups and subgroups</li>
<li>methods can take blocks as arguments, just note that 1) the block must come last, and 2) the name has to start with an &amp;</li>
<li>procs can be defines by instantiating the Proc-object: <code>say = Proc.new { |x, y, z| puts x }</code> and executed via <code>say.call('A', 'B', 'C')</code></li>
</ul>
